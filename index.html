<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Weekly Average Sentiment</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
        }
        .area {
            opacity: 0.7;
        }
        .axis-label {
            font-size: 12px;
            fill: #333;
        }
        .tooltip {
            position: absolute;
            background-color: white;
            padding: 8px;
            border: 1px solid #ccc;
            border-radius: 4px;
            pointer-events: none;
            font-size: 12px;
            color: #333;
        }
    </style>
</head>
<body>
    <h2 id="chart-title">Weekly Average Sentiment - Palestine</h2>

    <label for="dataset-select">Choose a topic:</label>
    <select id="dataset-select">
        <option value="palestine_sentiment.csv">Palestine</option>
        <option value="ukraine_sentiment.csv">Ukraine</option>
        <option value="trump_sentiment.csv">Trump</option>
    </select>

    <div id="chart"></div>
    <div id="tooltip" class="tooltip" style="opacity: 0;"></div>
    <script>
        const margin = { top: 20, right: 30, bottom: 50, left: 50 },
          width = 960 - margin.left - margin.right,
          height = 500 - margin.top - margin.bottom;
      
        const svg = d3.select("#chart")
          .append("svg")
          .attr("width", width + margin.left + margin.right)
          .attr("height", height + margin.top + margin.bottom)
          .append("g")
          .attr("transform", `translate(${margin.left},${margin.top})`);
      
        const parseDate = d3.timeParse("%Y-%m-%d %H:%M:%S");
      
        const tooltip = d3.select("#tooltip");
      
        const color = d3.scaleOrdinal()
          .domain(["positive", "negative"])
          .range(["green", "red"]);
      
        const x = d3.scaleTime().range([0, width]);
        const y = d3.scaleLinear().range([height, 0]);
      
        const stack = d3.stack().order(d3.stackOrderNone).offset(d3.stackOffsetNone);
      
        const area = d3.area()
          .x(d => x(d.data.date))
          .y0(d => y(d[0]))
          .y1(d => y(d[1]));
      
        // Add legend
        const legend = svg.append("g")
          .attr("class", "legend")
          .attr("transform", `translate(${width + 20}, 20)`);
      
        legend.selectAll("rect")
          .data(color.domain())
          .enter()
          .append("rect")
          .attr("x", 0)
          .attr("y", (d, i) => i * 20)
          .attr("width", 18)
          .attr("height", 18)
          .style("fill", color);
      
        legend.selectAll("text")
          .data(color.domain())
          .enter()
          .append("text")
          .attr("x", 25)
          .attr("y", (d, i) => i * 20 + 14)
          .text(d => d)
          .style("font-size", "12px");
      
        function findClosestWeek(targetDate, data) {
          return data.reduce((a, b) => 
            Math.abs(a.date - targetDate) < Math.abs(b.date - targetDate) ? a : b
          );
        }
      
        function updateChart(dataset) {
          d3.csv(dataset, d => {
            d.created = parseDate(d.created);
            d.date = d3.timeWeek.floor(d.created);
            for (let key in d) {
              if (key !== "created" && key !== "comment" && key !== "date") {
                d[key] = +d[key];
              }
            }
            return d;
          }).then(data => {
            const weeklyData = d3.groups(data, d => d.date).map(([date, values]) => {
              const emotions = Object.keys(values[0]).filter(
                key => !["created", "comment", "date", "neutral"].includes(key)
              );
              const total = d3.sum(values, d => d3.sum(emotions, e => d[e]));
              const averages = { date: new Date(date), totalComments: values.length };
              emotions.forEach(e => {
                averages[e] = total > 0 ? d3.sum(values, d => d[e]) / total : 0;
              });
              return averages;
            });
      
            const emotions = Object.keys(weeklyData[0]).filter(d => d !== "date" && d !== "totalComments");
      
            x.domain(d3.extent(weeklyData, d => d.date));
            y.domain([0, 1]);
      
            const stackedData = stack.keys(emotions)(weeklyData);
      
            svg.selectAll(".area").remove();
            svg.selectAll(".area")
              .data(stackedData)
              .enter().append("path")
              .attr("class", "area")
              .attr("d", area)
              .attr("fill", d => color(d.key))
              .on("mouseover", (event, d) => tooltip.style("opacity", 1))
              .on("mousemove", (event, d) => {
                const [xPos] = d3.pointer(event, svg.node());
                const date = x.invert(xPos);
                const closest = findClosestWeek(date, weeklyData);
                const emotion = d.key;
                const score = closest ? closest[emotion] : 0;
                const totalComments = closest ? closest.totalComments : 0;
                tooltip.html(`
                  <strong>Date:</strong> ${d3.timeFormat("%Y-%m-%d")(closest.date)}<br>
                  <strong>Sentiment:</strong> ${emotion}<br>
                  <strong>Score:</strong> ${score.toFixed(2)}<br>
                  <strong>Total Comments:</strong> ${totalComments}`)
                  .style("left", `${event.pageX + 15}px`)
                  .style("top", `${event.pageY - 30}px`);
              })
              .on("mouseout", () => tooltip.style("opacity", 0));
      
            svg.select(".x-axis").remove();
            svg.append("g")
              .attr("class", "x-axis")
              .attr("transform", `translate(0,${height})`)
              .call(d3.axisBottom(x).ticks(d3.timeWeek.every(1)))
              .selectAll("text")
              .attr("transform", "rotate(-45)")
              .style("text-anchor", "end");
      
            svg.select(".y-axis").remove();
            svg.append("g")
              .attr("class", "y-axis")
              .call(d3.axisLeft(y));
          });
        }
      
        d3.select("#dataset-select").on("change", function () {
          updateChart(this.value);
        });
      
        updateChart("palestine_sentiment.csv");
      </script>
    </body>
</html>
